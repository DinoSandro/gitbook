# Reversing assembly

## Ghidra

Ghidra is an open sourced decompiler

It takes machine code and generates code that resembles it's source code. However, since the process of compiling source code isn't like a 1 to 1 function, the code it gives us isn't always 100% correct

## gdb-gef

{% @github-files/github-code-block %}

In order to enter debugger mode, we can set breakpoints. Breakpoints are places in the program where GDB will know to stop execution to allow you to examine the contents of the stack. The most common breakpoint to set is on main, which we can set with 'break main' or 'b main'. Most GDB commands can be shortened.

Now you can step through the function by typing '`nexti`' until the program ends. 'nexti' will have you go instruction by intruction through the program, but will not step into function calls such as puts.

Other ways to navigate a program are:

* 'next' - which will take you through one line of code, but will step over function calls such as puts.
* 'step' - which will take you through one line of code, but will step into function calls
* 'stepi' - whch will take you through one instruction at a time, stepping into function calls

### [Breakpoints](https://guyinatuxedo.github.io/02-intro_tooling/gdb-gef/index.html#breakpoints)

Let's take a look at the main function using 'disassemble' or 'disass':

```
gef➤  disass main
Dump of assembler code for function main:
   0x080483fb <+0>:	lea    ecx,[esp+0x4]
   0x080483ff <+4>:	and    esp,0xfffffff0
   0x08048402 <+7>:	push   DWORD PTR [ecx-0x4]
   0x08048405 <+10>:	push   ebp
   0x08048406 <+11>:	mov    ebp,esp
   0x08048408 <+13>:	push   ecx
   0x08048409 <+14>:	sub    esp,0x4
   0x0804840c <+17>:	sub    esp,0xc
   0x0804840f <+20>:	push   0x80484b0
   0x08048414 <+25>:	call   0x80482d0 <puts@plt>
   0x08048419 <+30>:	add    esp,0x10
   0x0804841c <+33>:	mov    eax,0x0
   0x08048421 <+38>:	mov    ecx,DWORD PTR [ebp-0x4]
   0x08048424 <+41>:	leave  
   0x08048425 <+42>:	lea    esp,[ecx-0x4]
   0x08048428 <+45>:	ret    
End of assembler dump.

```

Let's say we wanted to break on the call to `puts`. We can do this by setting a breakpoint for that instruction.

Like this:

```
gef➤  b *main+25
Breakpoint 1 at 0x8048414
```

Or like this:

```
gef➤  b *0x08048414
Note: breakpoint 1 also set at pc 0x08048414
Breakpoint 2 at 0x08048414
```

When we run the binary and it tries to execute that instruction, the process will pause and drop us into the debugger console

We can also set breakpoints for functions like `puts`:

```
gef➤  b *puts
```

### [Viewing Things](https://guyinatuxedo.github.io/02-intro_tooling/gdb-gef/index.html#viewing-things)

So one thing that gdb is really useful for is viewing the values of different things. Once we are dropped into a debugger while the process is viewing, let's view the contents of the `esp`

We can see that the register `esp` holds the value `0xffffd0d0`, which is a pointer. Let's see what it points to:

```
gef➤  x/a 0xffffd0d0
0xffffd0d0:	0x80484b0
gef➤  x/10c 0x80484b0
0x80484b0:	0x68	0x65	0x6c	0x6c	0x6f	0x20	0x77	0x6f
0x80484b8:	0x72	0x6c
gef➤  x/s 0x80484b0
0x80484b0:	"hello world!"
```

Possible things include as an address `x/a`, a number of characters `x/10c` string `x/s`, as a qword `x/g`, or as a dword `x/w`.
